1ï¸âƒ£ PropÃ³sito del proyecto

PHP Micro Runtime es un proyecto educativo cuyo objetivo es comprender cÃ³mo
funciona internamente el ciclo request-response de un servidor HTTP, 
utilizando PHP como herramienta de aprendizaje, no como soluciÃ³n de producciÃ³n.

2ï¸âƒ£ QuÃ© ES el proyecto

Â· Un runtime HTTP mÃ­nimo.
Â· Un proceso largo controlado.
Â· Un laboratorio de arquitectura.
Â· Un proyecto de aprendizaje profundo.
Â· Un proyecto documentado y testeado.

3ï¸âƒ£ QuÃ© NO es el proyecto (muy importante).

Â· âŒ No es un reemplazo de Apache / Nginx.
Â· âŒ No es un servidor de producciÃ³n.
Â· âŒ No soporta alta concurrencia.
Â· âŒ No implementa HTTP completo.
Â· âŒ No gestiona TLS real.

4ï¸âƒ£ Alcance funcional (v1.0 educativa)

El runtime serÃ¡ capaz de:

Â· Escuchar en un puerto TCP.
Â· Aceptar conxiones secuenciales.
Â· Leer una peticiÃ³n HTTP simple.
Â· Pasear:
    Â· mÃ©todo.
    Â· URI.
    Â· headers bÃ¡sicos.
Â· Construir una respuesta HTTP vÃ¡lida.
Â· Escribirla en el socket.
Â· Cerrar la conexiÃ³n limpiamente.

5ï¸âƒ£ LÃ­mites tÃ©cnicos conscientes.

Â· Una conexiÃ³n a la vez.
Â· Sin multithreading.
Â· Sin async avanzado.
Â· Sin keep-alive complejo.
Â· Sin body parsing avanzado.

6ï¸âƒ£ Arquitectura conceptual (alto nivel)

Capas previstas:
    Â· Domain
        Â· Request
        Â· Response
    Â· Application
        Â· Runtime
        Â· Lifecycle
    Â· Infraestructure
        Â· Socket
        Â· IO
        Â· Config
        Â· Logger
SeparaciÃ³n estricta.
Responsabilidades claras.
Nada de clases "Dios".

ğŸ§± Arquitectura del ciclo Request-Response

1ï¸âƒ£ Vista general del ciclo

Describe el ciclo completo, a alto nivel:

1. El runtime inicia.
2. Se abre un socket TCP.
3. El runtime espera conexiones.
4. Un cliente se conecta.
5. Se lee la peticiÃ³n cruda.
6. Se transforma en un Request.
7. El sistema genera una Response.
8. Se escribe la respuesta en el socket.
9. Se cierra la conexiÃ³n.
10. El runtime vuelve a esperar conexiones.

2ï¸âƒ£ Componentes implicados

Define claramente los actores:

    Â· Runtime
        Â· Orquesta el ciclo.
        Â· Controla el bucle de ejecuciÃ³n.
    Â· Socket (Infraestructure)
        Â· ComunicaciÃ³n de bajo nivel.
        Â· Lectura / escritura.
    Â· Request (Domain)
        Â· Representa la peticiÃ³n HTTP.
        Â· Es inmutable (conceptualmente).
    Â· Response (Domain)
        Â· Representa la respuesta HTTP.
        Â· Construida por la aplicaciÃ³n.

3ï¸âƒ£ SeparaciÃ³n de responsabilidades (clave)

Â· Runtime NO parsea HTTP.
Â· Socket NO sabe quÃ© es HTTP.
Â· Request NO accede al socket.
Â· Response NO escribe en red.

Principio de responsabilidad Ãºnica.

4ï¸âƒ£ Flujo detallado (paso a paso)

- El Runtime delega en la capa Infraestructure la apertura del socket.
- Una vez Aceptada una conexiÃ³n, el Runtime solicita al componente IO la lectura del byffer.
- El contenido leÃ­do se pasa a un parser que construye un objeto Request....

5ï¸âƒ£ Errores y casos lÃ­mite (sin implementar)

Â· PeticiÃ³n mal formada.
Â· Lectura incompleta.
Â· MÃ©todo no soportado.
Â· Error interno.

6ï¸âƒ£ Decisiones conscientes

Â· Una conexiÃ³n a la vez.
Â· Modelo sincrono.
Â· Request inmutable.
Â· Response construida completamente antes de enviarse.

ğŸ” InvestigaciÃ³n: sockets y lÃ­mites en PHP

1ï¸âƒ£ Modelo de ejecuciÃ³n de PHP

Â· EstÃ¡ pensado para request/response corto.
Â· No procesos interminables.
Â· Puedes ejecutar procesos largos, pero con cuidado.

ConclusiÃ³n:
    PHP puede ejecutar un runtime largo, pero no es su caso de uso principal.

2ï¸âƒ£ ExtensiÃ³n sockets en PHP

Investigar y documentar:
Â· socket_create.
    Â· Crea un socket: socket_create(int $domain, int $type, int $protocol): Socket|false;
      
      Â· Crea un punto de comunicaciÃ³n (un socket) y devuelve una instancia de Socket. Una 
      conexiÃ³n tÃ­pica de red estÃ¡ compuesta por dos sockets: cliente y servidor.
      ref: https://www.php.net/manual/es/function.socket-create.php

Â· socket_bind.
    Â· Asocia un nombre a un socket: socket_bind(Socket $socket, string $address, int $port = 0): bool;

      Â· Asocia el nombre proporcionado por address a la interfaz de conexiÃ³n descrita por
      socket. Debe realizarse antes de establecer la conexiÃ³n usando socket_listen.
      ref: https://www.php.net/manual/es/function.socket-bind.php

Â· socket_listen.
    Â· Espera una coneciÃ³n en un socket: socket_listen(Socket $socket, int $backlog = 5): bool;
      
      Â· Una vez que el socket socket ha sido creado con la funciÃ³n socket_create() y vinculado
      a un nombre con socket_bind(), puede ponerse en espera.
      ref: https://www.php.net/manual/es/function.socket-listen.php

Â· socket_accept.
    Â· Acepta una conexiÃ³n en un socket: socket_accept(Socket $socket): Socket|false;
      Â· Una vez creado socket_create() y vinculado a un nombre socket_bind(), y puesto en escucha 
      socket_listen(), socket_accept() acepta una conexiÃ³n entrante.
      ref: https://www.php.net/manual/es/function.socket-accept.php

Â· socket_read.
    Â· Lee los datos de un socket: socket_read(Socket $socket, int $length, int $mode = PHP_BINARY_REAAD):
      string|false;
      Â· Lee los datos desde la instancia creada.
      ref: https://www.php.net/manual/es/function.socket-read.php

Â· socket_write.
    Â· Escribe un socket: socket_write(Socket $socket, string $data, int $mode = PHP_BINARY_WRITE):
      bool;
    Â· Escribe en un socket los datos del buffer data.
    ref: https://www.php.net/manual/es/function.socket-write.php

Â· socket_close.
    Â· Cierra una instancia de Socket: socket_close(Socket $socket): void;
    Â· cierra la instancia socket creada.
    ref: https://www.php.net/manual/es/function.socket-close.php

3ï¸âƒ£ Concurrencia en PHP (muy importante)

Â· PHP NO tiene multithreading nativo.
Â· pthreads estÃ¡:
    Â· Deprecated = obsoleto.
    Â· Limitado.
    Â· No disponible en entornos comunes.
Â· Nuestro runtime serÃ¡:
    Â· SÃ­ncrono.
    Â· Secuencial.
    Â· Una conexiÃ³n a la vez.

4ï¸âƒ£ GestiÃ³n de memoria y procesos largos.

Â· PHP puede consumir memoria si no se libera bien.
Â· Riesgo de leaks en procesos largos.
Â· Necesidad de:
    Â· Cerrar sockets.
    Â· No acumular estado.
    Â· Mantener objetos simples.

5ï¸âƒ£ SeÃ±ales y apagado limpio (conceptual)

Â· Este Runtime debe poder:
    Â· detenerse.
    Â· Cerrar socket.
    Â· Salir limpiamente.

6ï¸âƒ£ Conclusion de la InvestigaciÃ³n

PHP es valido para construir un micro runtime educativo basado en sockets, siempre que se asuman
sus lÃ­mites de concurrencia, memoria y modelo de ejecuciÃ³n. El proyecto se diseÃ±a conscientemente 
de esas restricciones.

